import { SwapSide, ContractMethod } from '../../constants';
import type { ConstructFetchInput, Address, AddressOrSymbol, PriceString, OptimalRate } from '../../types';
export declare enum PricingMethod {
    megapath = "megapath",
    multipath = "multipath",
    simplepath = "simplepath"
}
export declare type RateOptions = {
    excludeDEXS?: string[];
    includeDEXS?: string[];
    excludePools?: string[];
    excludePricingMethods?: PricingMethod[];
    excludeContractMethods?: ContractMethod[];
    includeContractMethods?: ContractMethod[];
    excludeContractMethodsWithoutFeeModel?: boolean;
    partner?: string;
    maxImpact?: number;
    maxUSDImpact?: number;
    otherExchangePrices?: boolean;
    /** @description proceed with priceRoute building even when tokens don't have USD price. Default: false */
    ignoreBadUsdPrice?: boolean;
    /** @description 	Specify that methods without fee support should be excluded from the price route. Default: false */
    exlcudeContractMethodsWithoutFeeModel?: boolean;
    /** @description If the source token is a tax token, you should specify the tax amount in BPS.  */
    srcTokenTransferFee?: string;
    /** @description If the destination token is a tax token, you should specify the tax amount in BPS.  */
    destTokenTransferFee?: string;
    /** @description Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.  */
    srcTokenDexTransferFee?: string;
    /** @description Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.  */
    destTokenDexTransferFee?: string;
};
declare type CommonGetRateInput = {
    amount: PriceString;
    userAddress?: Address;
    side?: SwapSide;
    options?: RateOptions;
    srcDecimals?: number;
    destDecimals?: number;
};
export declare type GetRateInput = CommonGetRateInput & {
    srcToken: AddressOrSymbol;
    destToken: AddressOrSymbol;
};
export declare type GetRate = (options: GetRateInput, signal?: AbortSignal) => Promise<OptimalRate>;
declare type GetRateByRouteInput = CommonGetRateInput & {
    route: AddressOrSymbol[];
};
declare type GetRateByRoute = (options: GetRateByRouteInput, signal?: AbortSignal) => Promise<OptimalRate>;
export declare type GetRateFunctions = {
    getRate: GetRate;
    getRateByRoute: GetRateByRoute;
};
export declare const constructGetRate: ({ apiURL, version, chainId, fetcher, }: ConstructFetchInput) => GetRateFunctions;
export {};
//# sourceMappingURL=rates.d.ts.map