"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("./contracts");
const types_1 = require("./types");
const common = tslib_1.__importStar(require("@protocolink/common"));
const ethers_1 = require("ethers");
const configs_1 = require("./configs");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
class Service extends common.Web3Toolkit {
    get protocolDataProvider() {
        if (!this._protocolDataProvider) {
            this._protocolDataProvider = contracts_1.ProtocolDataProvider__factory.connect((0, configs_1.getContractAddress)(this.chainId, 'ProtocolDataProvider'), this.provider);
        }
        return this._protocolDataProvider;
    }
    get protocolDataProviderIface() {
        if (!this._protocolDataProviderIface) {
            this._protocolDataProviderIface = contracts_1.ProtocolDataProvider__factory.createInterface();
        }
        return this._protocolDataProviderIface;
    }
    get lendingPoolIface() {
        if (!this._lendingPoolIface) {
            this._lendingPoolIface = contracts_1.LendingPool__factory.createInterface();
        }
        return this._lendingPoolIface;
    }
    async getLendingPoolAddress() {
        if (!this.lendingPoolAddress) {
            const addressProviderAddress = await this.protocolDataProvider.ADDRESSES_PROVIDER();
            this.lendingPoolAddress = await contracts_1.LendingPoolAddressesProvider__factory.connect(addressProviderAddress, this.provider).getLendingPool();
        }
        return this.lendingPoolAddress;
    }
    async getAssetAddresses() {
        if (!this.assetAddresses) {
            const lendingPoolAddress = await this.getLendingPoolAddress();
            const assetAddresses = await contracts_1.LendingPool__factory.connect(lendingPoolAddress, this.provider).getReservesList();
            const calls = assetAddresses.map((assetAddress) => ({
                target: this.protocolDataProvider.address,
                callData: this.protocolDataProviderIface.encodeFunctionData('getReserveConfigurationData', [assetAddress]),
            }));
            const { returnData } = await this.multicall3.callStatic.aggregate(calls);
            this.assetAddresses = [];
            for (let i = 0; i < assetAddresses.length; i++) {
                const assetAddress = assetAddresses[i];
                const { isActive, isFrozen } = this.protocolDataProviderIface.decodeFunctionResult('getReserveConfigurationData', returnData[i]);
                if (isActive && !isFrozen)
                    this.assetAddresses.push(assetAddress);
            }
        }
        return this.assetAddresses;
    }
    async getReserveTokensAddresses() {
        if (!this.reserveTokensAddresses) {
            const assetAddresses = await this.getAssetAddresses();
            const calls = assetAddresses.map((asset) => ({
                target: this.protocolDataProvider.address,
                callData: this.protocolDataProviderIface.encodeFunctionData('getReserveTokensAddresses', [asset]),
            }));
            const { returnData } = await this.multicall3.callStatic.aggregate(calls);
            this.reserveTokensAddresses = [];
            for (let i = 0; i < assetAddresses.length; i++) {
                const assetAddress = assetAddresses[i];
                const { rTokenAddress, stableDebtTokenAddress, variableDebtTokenAddress } = this.protocolDataProviderIface.decodeFunctionResult('getReserveTokensAddresses', returnData[i]);
                this.reserveTokensAddresses.push({
                    assetAddress,
                    rTokenAddress,
                    stableDebtTokenAddress,
                    variableDebtTokenAddress,
                });
            }
        }
        return this.reserveTokensAddresses;
    }
    async getAssets() {
        if (!this.assets) {
            const assetAddresses = await this.getAssetAddresses();
            this.assets = await this.getTokens(assetAddresses);
        }
        return this.assets;
    }
    async getRTokens() {
        if (!this.rTokens) {
            const reserveTokensAddresses = await this.getReserveTokensAddresses();
            const rTokenAddresses = reserveTokensAddresses.map((reserveTokensAddress) => reserveTokensAddress.rTokenAddress);
            this.rTokens = await this.getTokens(rTokenAddresses);
        }
        return this.rTokens;
    }
    async getReserveTokens() {
        if (!this.reserveTokens) {
            const reserveTokensAddresses = await this.getReserveTokensAddresses();
            const tokenAddresses = reserveTokensAddresses.reduce((accumulator, reserveTokensAddress) => {
                accumulator.push(reserveTokensAddress.assetAddress);
                accumulator.push(reserveTokensAddress.rTokenAddress);
                accumulator.push(reserveTokensAddress.stableDebtTokenAddress);
                accumulator.push(reserveTokensAddress.variableDebtTokenAddress);
                return accumulator;
            }, []);
            const tokens = await this.getTokens(tokenAddresses);
            this.reserveTokens = [];
            let j = 0;
            for (let i = 0; i < reserveTokensAddresses.length; i++) {
                const asset = tokens[j];
                j++;
                const rToken = tokens[j];
                j++;
                const stableDebtToken = tokens[j];
                j++;
                const variableDebtToken = tokens[j];
                j++;
                this.reserveTokens.push({ asset, rToken, stableDebtToken, variableDebtToken });
            }
        }
        return this.reserveTokens;
    }
    async toRToken(asset) {
        const { rTokenAddress } = await this.protocolDataProvider.getReserveTokensAddresses(asset.wrapped.address);
        return this.getToken(rTokenAddress);
    }
    async toRTokens(assets) {
        const calls = assets.map((asset) => ({
            target: this.protocolDataProvider.address,
            callData: this.protocolDataProviderIface.encodeFunctionData('getReserveTokensAddresses', [asset.wrapped.address]),
        }));
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        const rTokenAddresses = [];
        for (let i = 0; i < assets.length; i++) {
            const { rTokenAddress } = this.protocolDataProviderIface.decodeFunctionResult('getReserveTokensAddresses', returnData[i]);
            (0, tiny_invariant_1.default)(rTokenAddress !== ethers_1.constants.AddressZero, `unsupported asset: ${assets[i].wrapped.address}`);
            rTokenAddresses.push(rTokenAddress);
        }
        return this.getTokens(rTokenAddresses);
    }
    async toAsset(rToken) {
        const assetAddress = await contracts_1.AToken__factory.connect(rToken.address, this.provider).UNDERLYING_ASSET_ADDRESS();
        return this.getToken(assetAddress);
    }
    async getDebtTokenAddress(asset, interestRateMode) {
        const { stableDebtTokenAddress, variableDebtTokenAddress } = await this.protocolDataProvider.getReserveTokensAddresses(asset.wrapped.address);
        return interestRateMode === types_1.InterestRateMode.variable ? variableDebtTokenAddress : stableDebtTokenAddress;
    }
    async getFlashLoanPremiumTotal() {
        const lendingPoolAddress = await this.getLendingPoolAddress();
        const premium = await contracts_1.LendingPool__factory.connect(lendingPoolAddress, this.provider).FLASHLOAN_PREMIUM_TOTAL();
        return premium.toNumber();
    }
    async isDelegationApproved(account, delegateeAddress, assetAmount, interestRateMode) {
        const debtTokenAddress = await this.getDebtTokenAddress(assetAmount.token, interestRateMode);
        const borrowAllowance = await contracts_1.DebtTokenBase__factory.connect(debtTokenAddress, this.provider).borrowAllowance(account, delegateeAddress);
        return borrowAllowance.gte(assetAmount.amountWei);
    }
    async buildApproveDelegationTransactionRequest(delegateeAddress, assetAmount, interestRateMode) {
        const to = await this.getDebtTokenAddress(assetAmount.token, interestRateMode);
        const iface = contracts_1.DebtTokenBase__factory.createInterface();
        const data = iface.encodeFunctionData('approveDelegation', [delegateeAddress, ethers_1.constants.MaxUint256]);
        return { to, data };
    }
    async getFlashLoanConfiguration(assets) {
        const rTokens = await this.toRTokens(assets);
        const poolAddress = await this.getLendingPoolAddress();
        const calls = [
            { target: poolAddress, callData: this.lendingPoolIface.encodeFunctionData('FLASHLOAN_PREMIUM_TOTAL') },
        ];
        for (let i = 0; i < assets.length; i++) {
            const assetAddress = assets[i].wrapped.address;
            calls.push({
                target: this.protocolDataProvider.address,
                callData: this.protocolDataProviderIface.encodeFunctionData('getReserveConfigurationData', [assetAddress]),
            });
            calls.push({
                target: assetAddress,
                callData: this.erc20Iface.encodeFunctionData('balanceOf', [rTokens[i].address]),
            });
        }
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        let j = 0;
        const [premium] = this.lendingPoolIface.decodeFunctionResult('FLASHLOAN_PREMIUM_TOTAL', returnData[j]);
        const feeBps = premium.toNumber();
        j++;
        const assetInfos = [];
        for (let i = 0; i < assets.length; i++) {
            const { isActive } = this.protocolDataProviderIface.decodeFunctionResult('getReserveConfigurationData', returnData[j]);
            j++;
            const [balance] = this.erc20Iface.decodeFunctionResult('balanceOf', returnData[j]);
            const availableToBorrow = new common.TokenAmount(assets[i]).setWei(balance);
            j++;
            assetInfos.push({ isActive, availableToBorrow });
        }
        return { feeBps: feeBps, assetInfos };
    }
}
exports.Service = Service;
//# sourceMappingURL=service.js.map