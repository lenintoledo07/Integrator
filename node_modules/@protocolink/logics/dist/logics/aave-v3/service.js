"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("./contracts");
const types_1 = require("./types");
const common = tslib_1.__importStar(require("@protocolink/common"));
const ethers_1 = require("ethers");
const configs_1 = require("./configs");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
class Service extends common.Web3Toolkit {
    get poolDataProvider() {
        if (!this._poolDataProvider) {
            this._poolDataProvider = contracts_1.PoolDataProvider__factory.connect((0, configs_1.getContractAddress)(this.chainId, 'PoolDataProvider'), this.provider);
        }
        return this._poolDataProvider;
    }
    get poolDataProviderIface() {
        if (!this._poolDataProviderIface) {
            this._poolDataProviderIface = contracts_1.PoolDataProvider__factory.createInterface();
        }
        return this._poolDataProviderIface;
    }
    get poolIface() {
        if (!this._poolIface) {
            this._poolIface = contracts_1.Pool__factory.createInterface();
        }
        return this._poolIface;
    }
    async getPoolAddress() {
        if (!this.poolAddress) {
            const addressProviderAddress = await this.poolDataProvider.ADDRESSES_PROVIDER();
            this.poolAddress = await contracts_1.PoolAddressesProvider__factory.connect(addressProviderAddress, this.provider).getPool();
        }
        return this.poolAddress;
    }
    async getAssetAddresses() {
        if (!this.assetAddresses) {
            const poolAddress = await this.getPoolAddress();
            const assetAddresses = await contracts_1.Pool__factory.connect(poolAddress, this.provider).getReservesList();
            const calls = assetAddresses.map((assetAddress) => ({
                target: this.poolDataProvider.address,
                callData: this.poolDataProviderIface.encodeFunctionData('getReserveConfigurationData', [assetAddress]),
            }));
            const { returnData } = await this.multicall3.callStatic.aggregate(calls);
            this.assetAddresses = [];
            for (let i = 0; i < assetAddresses.length; i++) {
                const assetAddress = assetAddresses[i];
                const { isActive, isFrozen } = this.poolDataProviderIface.decodeFunctionResult('getReserveConfigurationData', returnData[i]);
                if (isActive && !isFrozen)
                    this.assetAddresses.push(assetAddress);
            }
        }
        return this.assetAddresses;
    }
    async getReserveTokensAddresses() {
        if (!this.reserveTokensAddresses) {
            const assetAddresses = await this.getAssetAddresses();
            const calls = assetAddresses.map((asset) => ({
                target: this.poolDataProvider.address,
                callData: this.poolDataProviderIface.encodeFunctionData('getReserveTokensAddresses', [asset]),
            }));
            const { returnData } = await this.multicall3.callStatic.aggregate(calls);
            this.reserveTokensAddresses = [];
            for (let i = 0; i < assetAddresses.length; i++) {
                const assetAddress = assetAddresses[i];
                const { aTokenAddress, stableDebtTokenAddress, variableDebtTokenAddress } = this.poolDataProviderIface.decodeFunctionResult('getReserveTokensAddresses', returnData[i]);
                this.reserveTokensAddresses.push({
                    assetAddress,
                    aTokenAddress,
                    stableDebtTokenAddress,
                    variableDebtTokenAddress,
                });
            }
        }
        return this.reserveTokensAddresses;
    }
    async getAssets() {
        if (!this.assets) {
            const assetAddresses = await this.getAssetAddresses();
            this.assets = await this.getTokens(assetAddresses);
        }
        return this.assets;
    }
    async getATokens() {
        if (!this.aTokens) {
            const reserveTokensAddresses = await this.getReserveTokensAddresses();
            const aTokenAddresses = reserveTokensAddresses.map((reserveTokensAddress) => reserveTokensAddress.aTokenAddress);
            this.aTokens = await this.getTokens(aTokenAddresses);
        }
        return this.aTokens;
    }
    async getReserveTokens() {
        if (!this.reserveTokens) {
            const reserveTokensAddresses = await this.getReserveTokensAddresses();
            const tokenAddresses = reserveTokensAddresses.reduce((accumulator, reserveTokensAddress) => {
                accumulator.push(reserveTokensAddress.assetAddress);
                accumulator.push(reserveTokensAddress.aTokenAddress);
                accumulator.push(reserveTokensAddress.stableDebtTokenAddress);
                accumulator.push(reserveTokensAddress.variableDebtTokenAddress);
                return accumulator;
            }, []);
            const tokens = await this.getTokens(tokenAddresses);
            this.reserveTokens = [];
            let j = 0;
            for (let i = 0; i < reserveTokensAddresses.length; i++) {
                const asset = tokens[j];
                j++;
                const aToken = tokens[j];
                j++;
                const stableDebtToken = tokens[j];
                j++;
                const variableDebtToken = tokens[j];
                j++;
                this.reserveTokens.push({ asset, aToken, stableDebtToken, variableDebtToken });
            }
        }
        return this.reserveTokens;
    }
    async toAToken(asset) {
        const { aTokenAddress } = await this.poolDataProvider.getReserveTokensAddresses(asset.wrapped.address);
        (0, tiny_invariant_1.default)(aTokenAddress !== ethers_1.constants.AddressZero, `unsupported asset: ${asset.wrapped.address}`);
        return this.getToken(aTokenAddress);
    }
    async toATokens(assets) {
        const calls = assets.map((asset) => ({
            target: this.poolDataProvider.address,
            callData: this.poolDataProviderIface.encodeFunctionData('getReserveTokensAddresses', [asset.wrapped.address]),
        }));
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        const aTokenAddresses = [];
        for (let i = 0; i < assets.length; i++) {
            const { aTokenAddress } = this.poolDataProviderIface.decodeFunctionResult('getReserveTokensAddresses', returnData[i]);
            (0, tiny_invariant_1.default)(aTokenAddress !== ethers_1.constants.AddressZero, `unsupported asset: ${assets[i].wrapped.address}`);
            aTokenAddresses.push(aTokenAddress);
        }
        return this.getTokens(aTokenAddresses);
    }
    async toAsset(aToken) {
        const assetAddress = await contracts_1.AToken__factory.connect(aToken.address, this.provider).UNDERLYING_ASSET_ADDRESS();
        return this.getToken(assetAddress);
    }
    async getDebtTokenAddress(asset, interestRateMode) {
        const { stableDebtTokenAddress, variableDebtTokenAddress } = await this.poolDataProvider.getReserveTokensAddresses(asset.wrapped.address);
        return interestRateMode === types_1.InterestRateMode.variable ? variableDebtTokenAddress : stableDebtTokenAddress;
    }
    async getFlashLoanPremiumTotal() {
        const poolAddress = await this.getPoolAddress();
        const premium = await contracts_1.Pool__factory.connect(poolAddress, this.provider).FLASHLOAN_PREMIUM_TOTAL();
        return premium.toNumber();
    }
    async isDelegationApproved(account, delegateeAddress, assetAmount, interestRateMode) {
        const debtTokenAddress = await this.getDebtTokenAddress(assetAmount.token, interestRateMode);
        const borrowAllowance = await contracts_1.DebtTokenBase__factory.connect(debtTokenAddress, this.provider).borrowAllowance(account, delegateeAddress);
        return borrowAllowance.gte(assetAmount.amountWei);
    }
    async buildApproveDelegationTransactionRequest(delegateeAddress, assetAmount, interestRateMode) {
        const to = await this.getDebtTokenAddress(assetAmount.token, interestRateMode);
        const iface = contracts_1.DebtTokenBase__factory.createInterface();
        const data = iface.encodeFunctionData('approveDelegation', [delegateeAddress, ethers_1.constants.MaxUint256]);
        return { to, data };
    }
    async getFlashLoanConfiguration(assets) {
        const aTokens = await this.toATokens(assets);
        const poolAddress = await this.getPoolAddress();
        const calls = [
            { target: poolAddress, callData: this.poolIface.encodeFunctionData('FLASHLOAN_PREMIUM_TOTAL') },
        ];
        for (let i = 0; i < assets.length; i++) {
            const assetAddress = assets[i].wrapped.address;
            calls.push({
                target: this.poolDataProvider.address,
                callData: this.poolDataProviderIface.encodeFunctionData('getPaused', [assetAddress]),
            });
            calls.push({
                target: this.poolDataProvider.address,
                callData: this.poolDataProviderIface.encodeFunctionData('getReserveConfigurationData', [assetAddress]),
            });
            calls.push({
                target: this.poolDataProvider.address,
                callData: this.poolDataProviderIface.encodeFunctionData('getFlashLoanEnabled', [assetAddress]),
            });
            calls.push({
                target: assetAddress,
                callData: this.erc20Iface.encodeFunctionData('balanceOf', [aTokens[i].address]),
            });
        }
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        let j = 0;
        const [premium] = this.poolIface.decodeFunctionResult('FLASHLOAN_PREMIUM_TOTAL', returnData[j]);
        const feeBps = premium.toNumber();
        j++;
        const assetInfos = [];
        for (let i = 0; i < assets.length; i++) {
            const [isPaused] = this.poolDataProviderIface.decodeFunctionResult('getPaused', returnData[j]);
            j++;
            const { isActive } = this.poolDataProviderIface.decodeFunctionResult('getReserveConfigurationData', returnData[j]);
            j++;
            const [isFlashLoanEnabled] = this.poolDataProviderIface.decodeFunctionResult('getFlashLoanEnabled', returnData[j]);
            j++;
            const [balance] = this.erc20Iface.decodeFunctionResult('balanceOf', returnData[j]);
            const availableToBorrow = new common.TokenAmount(assets[i]).setWei(balance);
            j++;
            assetInfos.push({ isPaused, isActive, isFlashLoanEnabled, availableToBorrow });
        }
        return { feeBps: feeBps, assetInfos };
    }
}
exports.Service = Service;
//# sourceMappingURL=service.js.map